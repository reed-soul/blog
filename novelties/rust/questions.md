# questions

## 变量

1. 如果有一个数据结构需要在多个线程中访问，可以把它放在栈上吗？为什么？
不能，栈上的数据会随着当前线程的函数调用栈而回收，多个线程访问须在堆上开辟。

2. 可以使用指针引用栈上的某个变量吗？如果可以，在什么情况下可以这么做？
可以，在当前函数调用栈中，可以新建变量在栈上开辟，顺便分配一个指针指向它，但是注意，这个指针的生命周期只能在当前栈帧中，不能作为返回值给别人用。

提一下，通篇读下来，明显感受到老师的内容极其深厚，能在各种语言之间斡旋，尖锐地指出每一门语言的特点，顺便再谈谈 rust 是如何解决它们的痛点，这才是 rust 真正的精髓所在。

rust 作为极其现代的语言，集百家之长而成，当然错误处理至今仍然很拉垮，将性能和安全做到了极致，但同时也带来了巨大的学习曲线，初学时，经常出现满屏的编译错误，每天都在和编译器做斗争。

也正是因为编译器极其严苛的规则，导致 rust 程序拥有无与伦比的信任度，基本编译通过、单测跑完就敢上线，去年有幸上线过 rust 项目，相较于原来的 java 版，无论是内存还是性能都带来了巨大提升，尤其是内存，几乎缩小了 80 倍左右。

未来很大程度上，rust 虽然不会成为主流，因为难，但它会是语言界的扫地僧。

作者回复: 嗯，@pedro 回答得很详尽了。我补充一下。1. 在多线程场景下，每个线程的生命周期是不固定的，无法在编译期知道谁先结束谁后结束，所以你不能把属于某个线程 A 调用栈上的内存共享给线程 B，因为 A 可能先于 B 结束。这时候，只能使用堆内存。这里有个例外，如果结束的顺序是确定的，那么可以共享，比如 scoped thread；2. 而同一个调用栈下，main() 调用 hello()，再调用 world()，编译器很清楚，world() 会先结束，之后是 hello()，最后是 main()。所以在 world() 下用指针引用 hello() 或者 main() 内部的变量没有问题，这个指针必然先于它指向的值结束。这个两个问题的实质是我们要搞明白哪些东西在编译期可以确定它们的关系或者因果，哪些只能在运行期确定。

3. 关于可执行文件加载string literal 到内存，如果不同的两个函数，foo() 和bar()中，各自都用到了一个string literal “hello”, 那么编译器从从可执行文件.rodata 中加载内存，是加载一份”hello”，还是两份？

作者回复: 是一份。它们指向 .rodata 中同样的地址。你可以用这段代码测试一下：

```rust
fn main() {
    let x = "hello world";
    println!("x = {:p}", x);
    foo();
}

fn foo() {
    let v = "hello world";
    println!("v = {:p}", v);
}
```

4. Rust 中 const 常量存储在什么地方，和 static var 是一个地方吗？
作者回复: 和操作系统和 CPU 有关，比如 linux 下可能是 .TEXT 或者 .RODATA 段。
